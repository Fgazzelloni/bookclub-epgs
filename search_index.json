[["index.html", "Engineering Production-Grade Shiny Apps Book Club Welcome", " Engineering Production-Grade Shiny Apps Book Club The R4DS Online Learning Community 2021-12-01 Welcome This is a companion for the book Engineering Production-Grade Shiny Apps by Colin Fay, Sébastien Rochette, Vincent Guyader, and Cervan Girard. This companion is available at r4ds.io/epgs. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book. This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["about-successful-shiny-apps.html", "Chapter 1 About Successful {shiny} Apps", " Chapter 1 About Successful {shiny} Apps Learning objectives: Intro to shiny Consider application complexity from different viewpoints "],["introduction.html", "1.1 Introduction", " 1.1 Introduction 1.1.1 Motivation for the book (&amp; the bookclub) 1.1.2 Audience for the book (experienced) shiny devs managers 1.1.3 What is “Production”? Used Relied upon Real life impact "],["intro-to-shiny.html", "1.2 Intro to {shiny}", " 1.2 Intro to {shiny} Building apps in R .. without necessarily needing HTML, CSS, JS training Need {shiny} apps always be a proof-of-concept? "],["what-is-a-complex-shiny-application.html", "1.3 What is a complex {shiny} application?", " 1.3 What is a complex {shiny} application? Complexity: [a complex system] defies any single person&#39;s ability to see [and understand] the system as a whole Consequences: Bug chasing Steep learning curve "],["types-of-complexity.html", "1.4 Types of complexity", " 1.4 Types of complexity Developer complexity Implementation Development Deployment Customer / User complexity Interface "],["code-complexity.html", "1.5 Code complexity", " 1.5 Code complexity Lines of code Number of files Cyclomatic complexity Other sources: Inconsistency Indentation Untested code Dependency-bloat Maintenance and Use Merge-conflicts per week … "],["app-complexity.html", "1.6 App complexity?", " 1.6 App complexity? External dependencies: databases, APIs etc Number of contributors "],["what-is-a-successful-shiny-app.html", "1.7 What is a successful {shiny} app?", " 1.7 What is a successful {shiny} app? Existence Accuracy Usability Immortality "],["meeting-videos.html", "1.8 Meeting Videos", " 1.8 Meeting Videos 1.8.1 Cohort 1 Meeting chat log 00:10:22 Ryan Metcalf: https://unleash-shiny.rinterface.com/index.html "],["planning-ahead.html", "Chapter 2 Planning Ahead ", " Chapter 2 Planning Ahead "],["prepare-for-success.html", "2.1 Prepare for Success", " 2.1 Prepare for Success Learning Objectives: Learn the KISS method Establish good version control and CI / Test Comprehend development team hierarchy French proverb: Rome ne fut pas faite toute en un jour. English Translation: Rome was not made all in one day. The chapter is preparing for a project Projects that aren’t planned well encure additional cost to unwrangle bad code Setting Version Control Organizing a hierarchy of personnel The sooner you start with a robust framework the better, and the longer you wait the harder it gets to convert your application to a production-ready one. "],["develop-with-the-kiss-principle.html", "2.2 Develop with the KISS principle", " 2.2 Develop with the KISS principle Definition: Keep It Simple Stupid Kelly Johnson of Lockheed Skunkworks Develop with a common set of tools Tidyverse Dplyr ggplot2 etc… Expand on this topic for military style of lowest common denominator. Simple is success. Various levels of workforce aptitude lead towards varying degrees of success If your team chooses to use abstract packages or web applications, ensure there is a good reason. The more complex you build your orchestration, the harder it will be to find talent to maintain the service. Example: Microsoft or Oracle "],["working-as-a-team-tools-and-structure.html", "2.3 Working as a team: Tools and structure", " 2.3 Working as a team: Tools and structure The choice of tools and how the team is structured is crucial for a successful application. Not entirely like KISS, but close too it. GitHub versus GitLab. Barebones hardware or Containerization. 2.3.1 From the tools point of view Version control and test all things Use Constant Innovation (CI) principles to test all code before committing Breaking things is a natural process of software engineering, notably when working on a piece of code during a long period Be informed that the codebase is broken Be able to identify changes between versions, and potentially, get back in time to a previous codebase Github/GitLab diff-docs. Example: Branch -&gt; Change -&gt; Test -&gt; Commit -&gt; Pull Request -&gt; Merge Small is beautiful Smaller more managable pieces make it easier to develop Teams may even work in parallel (with caution) A large codebase implies that the safe way to work is to split the app into pieces Extract your core “non-reactive” functions, which we will also call the “business logic”, and include them in external files Non-vital linkages (data ingestion pipelines) Page Layout and theming (CSS or branding characteristics) Allows for expansion but won’t break the core 2.3.2 From the team point of view Select a Manager, maybe a stakeholder or project manager. Someone who may or may not work on the codebase but is aware and knowledgeable Select one or more core developers skilled but specific in their field of study Follow git workflow with issue tracking and managing pull requests ## Reference Lemaire, Maude. 2020. Refactoring at Scale. Henry Holt. NOTE: Payed Service "],["structuring-your-project.html", "Chapter 3 Structuring Your Project", " Chapter 3 Structuring Your Project Learning Objectives Learn the golem file structure for building shiny apps Manage Dependencies and Namespace files Apply proper documentation principles for app maintenance, use, and future development Comprehend the future use of golem "],["shiny-app-as-a-package.html", "3.1 {shiny} app as a package", " 3.1 {shiny} app as a package golem is an opinionated framework for building production-ready {shiny} applications learn the basic now…the rest of the book relies on it 3.1.1 What is in a production-grade {shiny} app? Use one single file, or split into two?….that is the question! We will discover, this is an arbitrary question when managing large production level shiny apps Modulizing code will be your success factor It has metadata This could include: naming convention, version numbering, what the app does, who to contact when it breaks….and it WILL break It handles dependencies You need to handle them, and handle them correctly if you want to ensure a smooth deployment to production DESCRIPTION: contains the packages your application depends on NAMESPACE: contains the functions/packages you need to import It’s split into functions When apps get big…spread the wealth to smaller manageable files The smaller files go into the R/ directory It has documentation Document, Document, Document!!! README can be simple like a markdown file Vignettes are a bit more complex, possibly with examples Function documentation could include inline notes You may even create a {pkgdown} webpage for IT and other developers It’s tested Nothing should go to production without being tested. Nothing. examples could include {testhat} There is a native way to build and deploy it Finally, create a tar.gz file to make it easy for distribution 3.1.2 Resources R packages Building a Package that Lasts Writing R Extensions R Package Primer - a Minimal Tutorial "],["using-shiny-modules.html", "3.2 Using {shiny} modules", " 3.2 Using {shiny} modules Modulizing code will be your success factor 3.2.1 Why {shiny} modules? The one million “Validate” buttons problem Creating small namespaces where you can safely define ids without conflicting with other ids in the app When you single app gets bigger….UI and Server exchange may be hundreds or thousands of lines apart. That is a lot of scrolling! Working with a bite-sized codebase if you copy and paste something more than twice, you should make a function {shiny} modules aim at three things: simplify “id” namespacing split the codebase into a series of functions allow UI/Server parts of your app to be reused Most of the time, modules are used to do the two first. In our case, we could say that 90% of the modules we write are never reused, they are here to allow us to split the codebase into smaller, more manageable pieces. 3.2.2 When to use {shiny} modules Start right from the beginning Yes, this takes a bit more time, but you will be saving yourselve volumes in the future (Your future self will love you!) 3.2.3 A practical walkthrough (Big code base example. Talk through the best way to compare) 1. Your first {shiny} module 2. Passing arguments to your modules - UseLink 3.2.4 Communication between modules Three primary ways to share data amongst modules: - Returning a reactive function - The “stratégie du petit r” (to be pronounced with a French accent of course) - The “stratégie du grand R6” Returning values from the module using reactive calls is costly on the server The “stratégie du petit r” creates a sudo database shared amongst modules. More efficent, but not eloquent The “stratégie du grand R6” {R6} package. The best of both worlds may be foreign to some Other approaches: About {tidymodules} "],["structuring-your-app.html", "3.3 Structuring your app", " 3.3 Structuring your app A shiny app has two main components: - Application logic is what makes your {shiny} app interactive - Business logic includes the components with the core algorithms and functions that make your application specific to your area of work 3.3.1 Small is beautiful (bis repetita) Long scripts are almost always synonymous with complexity when it comes to building software 3.3.2 Conventions matter app_*.R (typically app_ui.R and app_server.R) contain the top-level functions defining your user interface and your server function. fct_* files contain the business logic, which are potentially large functions. They are the backbone of the application and may not be specific to a given module. They can be added using {golem} with the add_fct(“name”) function. mod_* files contain a unique module. Many {shiny} apps contain a series of tabs, or at least a tab-like pattern, so we suggest that you number them according to their step in the application. Tabs are almost always named in the user interface, so that you can use this tab name as the file name. For example, if you build a dashboard where the first tab is called “Import”, you should name your file mod_01_import.R. You can create this file with a module skeleton using golem::add_module(“01_import”). utils_* are files that contain utilities, which are small helper functions. For example, you might want to have a not_na, which is not_na &lt;- Negate(is.na), a not_null, or small tools that you will be using application-wide. Note that you can also create utils for a specific module. *_ui_*, for example utils_ui.R, relates to the user interface. *_server_* are files that contain anything related to the application’s back-end. For example, fct_connection_server.R will contain functions that are related to the connection to a database, and are specifically used from the server side. "],["introduction-to-golem.html", "Chapter 4 Introduction to Golem", " Chapter 4 Introduction to Golem "],["the-workflow.html", "Chapter 5 The Workflow", " Chapter 5 The Workflow "],["user-experience---ux.html", "Chapter 6 User experience - UX", " Chapter 6 User experience - UX Learning objectives: the key factors for a successful app understanding of your audience behavior "],["introduction-1.html", "6.1 Introduction", " 6.1 Introduction This chapter focuses on the key factors for making a Shiny app successful. Figure 6.1: Shiny success The back-yard vs the front-end The first take away of this chapter is that thinking about the “behind the scene” of your building app can be challenging for a successful front-end. "],["simplicity-is-gold.html", "6.2 Simplicity is gold", " 6.2 Simplicity is gold Establish some rules about your app to be: simple the app must be fast usable straightforward easy to approach and use Based on the identification of the destination of the app: for professional use for fun The quicker you understand the interface, the better the user experience (in business) Don’t fight against the app but enjoy it (for fun) Figure 6.2: Yes and No of your app Yes: “self-explanatory” but with detailed explanations an efficient tool No: fight with interface read complex material lose time understanding how to use it Two more important rules: “don’t make me think” “rule of least surprise”: “Principle of Least Astonishment” 6.2.1 How we read the web: Scanning content The second part of this chapter focuses on what your audience is actually seeing about the app. The user of your app doesn’t read everything, but will be searching for “How to”? Figure 6.3: “How to”? The user might act unexpectedly on you app adopt “defensive programming” mindset is a workaround the unexpected: inherent logic in the application: each sub-menu is designed to handle one specific part of your app rational choice: rationality plays a good game but it is less than expected when up to a new app “irrational” choices: examine the back-end for unexpected behaviors \"organisms adapt well enough to ‘satisfice’; they do not, in general, optimize.“ by Herbert A. Simon To be failing gracefully and informatively can sometimes happen, but do not forget to put an informative bug message to avoid a grayish version of the application. Under some conditions you might not have the complete manner of all that is linked with your app (such as widgets in {DT} package) Good practices: add a bug message wrap all server calls (in case of crash reduce the amount of data loss) use a notification function with {shinyalert} and/or {attempt} packages As an example, if we want our app to be connected to a database, we use connect_db() connection in the server(). If the connection fails, we notify the user: conn &lt;- attempt::attempt({ connect_db() }) if (attempt::is_try_error(conn)){ # Notify the user send_notification(&quot;Could not connect&quot;) } else { # Continue computing if the connection was successful continue_computing() } 6.2.2 Building a self-evident app (or at least self-explanatory) self-evident: no demo required self-explanatory: no explanation required A. About the “Rule of Least Surprise” and the “Principle of Least Astonishment” various text customization lead to conventional thinking B. Thinking about progression design a clear pattern of moving forward hide elements at step n+1 until all the requirements are fulfilled at step n. ensure some kind of linear logic through increasing readability compare {tidytuesday201942} to {hexmake} C. Inputs and errors Your user is BUSY BUSY BEE …. In the UI: useShinyFeedback() In the server(): showFeedbackWarning() hideFeedback() ( the notifyjsexample repository link doesn’t work ) "],["the-danger-of-feature-creep.html", "6.3 The danger of feature-creep", " 6.3 The danger of feature-creep Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do. The Art of UNIX Programming (Raymond 2003) 6.3.1 What is feature-creep? The process of adding features to the app that complicate the usage and the maintenance of the product, such as: easier navigation more information more visualizations modifiable elements … What’s behind feature-creep? adding more and more things most often leads to: a slower app worse user experience steeper learning curve 6.3.2 Too much reactivity Prevent the implementation of “full reactivity” This is a very important part of how to make an app working smoothly, releasing the best experience to users. The book reminds that: people make mistakes while using the app be sure your app doesn’t update all the times at any given imputs If the application reacts to all of the moves, the experience using the app can be bad, imagine that all the elements on the app update at any user input The best solution is to add one reactive button to give the user the opportunity to update results once all the changes have been made. 6.3.3 Too much interactivity A. Speed: use the features that assure fast visualizations at a given input B. Visual noise: reduce the numbers of extra features "],["web-accessibility.html", "6.4 Web accessibility", " 6.4 Web accessibility 6.4.1 About accessibility Audience: large audience Figure 6.4: Accessibility in Context 6.4.2 Making your app accessible A. Hierarchy: respect the order of importance B. HTML element: Semantic tags, and tag metadata: without “meanings”: &lt;div&gt; or &lt;span&gt; have a specific “meanings”: meaningful (Semantic tags) &lt;title&gt; or &lt;article&gt; &lt;address&gt;, &lt;video&gt;, or &lt;label&gt; metadata alt we can use the tagAppendAttributes() ui &lt;- function(){ tagList( plotOutput(&quot;plot&quot;) %&gt;% # Adding the `alt` attribute to our plot tagAppendAttributes(alt = &quot;Plot of iris&quot;) ) } It will be crucial to screen-to-speech technology: the software will read the &lt;title&gt; tag, jump to the &lt;nav&gt;, or straight to the ` on the page. C. Navigation: make everything doable with a keyboard textInput() with a validation button and {nter} package # Adapted from https://github.com/JohnCoene/nter library(nter) library(shiny) ui &lt;- fluidPage( # Setting a text input and a button textInput(&quot;text&quot;, &quot;&quot;), # This button will be clicked when &#39;Enter&#39; is pressed in # the textInput text actionButton(&quot;send&quot;, &quot;Do not click hit enter&quot;), verbatimTextOutput(&quot;typed&quot;), # define the rule nter(&quot;send&quot;, &quot;text&quot;) ) server &lt;- function(input, output) { r &lt;- reactiveValues() # Define the behavior on click observeEvent( input$send , { r$printed &lt;- input$text }) # Render the text output$typed &lt;- renderPrint({ r$printed }) } shinyApp(ui, server) D. Color choices: recommended to use provided color composition such as viridis or other specific combinations. Here as an example is the build of a function, but other packages can be used such as {dichromat} packages which simulates color blindness. with_palette &lt;- function(palette) { x &lt;- y &lt;- seq(-8 * pi, 8 * pi, len = 40) r &lt;- sqrt(outer(x^2, y^2, &quot;+&quot;)) z &lt;- cos(r^2) * exp(-r / (2 * pi)) filled.contour( z, axes = FALSE, color.palette = palette, asp = 1 ) } with_palette(matlab::jet.colors) 6.4.3 Evaluating your app accessibility and further reading How to evaluate accessibility? A. Emulate vision deficiency using Google Chrome B. External tools "],["references.html", "6.5 References", " 6.5 References shinyalert Hexmake app Accessibility Freecodecamp - tutorial nter package Color blindness "],["dont-rush-into-coding.html", "Chapter 7 Don’t Rush into Coding", " Chapter 7 Don’t Rush into Coding "],["setting-up-for-success-with-golem.html", "Chapter 8 Setting Up for Success with {golem}", " Chapter 8 Setting Up for Success with {golem} Learning Objectives Initialize Golem framework Populate the framework with details Review the Folder Structure Comprehend how here works "],["setting-up-for-success-with-golem-1.html", "8.1 Setting up for Success with {golem}", " 8.1 Setting up for Success with {golem} Developer Workflow: PM sets up golem project first steps filled general structure is set project is registered to version control Start to prototyping the UI work on CSS and JS elements work on back-end functionalities Work on integration of everything inside reacitve context "],["create-a-golem.html", "8.2 Create a {golem}", " 8.2 Create a {golem} Install libraries (if required) File -&gt; New Project -&gt; Select “Package for shiny app Using golem” Alternative, see code snippet below. Replace path/to/package with your known namespace. library(here) library(golem) # Creating a golem project from the command line golem::create_golem(path = &quot;~/Documents/GitHub/bookclub-epgs/golex&quot;) You can view your new project directory structure using: # This is what a default {golem} project looks like # Listing the files from the `golex` project using {fs} fs::dir_tree(&quot;golex&quot;) NOTE: If you get and output with fs::dir_tree(\"golex\") your package is working properly "],["setting-things-up-with-dev01_start.html", "8.3 Setting things up with dev/01_start.R", " 8.3 Setting things up with dev/01_start.R dev/01_start.R is the first file that you need to populate and run. 8.3.1 Fill the DESCRIPTION and set options Within the dev/01_start.R file, you need to populate some pertinent information related to your project. NOTE: This is an automated system. Only edit and run this file first as the remaining steps will be completed in sequence for proper packaging process. golem::fill_desc( # The Name of the package containing the App pkg_name = &quot;ipsumapp&quot;, # The Title of the package containing the App pkg_title = &quot;PKG_TITLE&quot;, # The Description of the package containing the App pkg_description = &quot;PKG_DESC.&quot;, # Your First Name author_first_name = &quot;AUTHOR_FIRST&quot;, # Your Last Name author_last_name = &quot;AUTHOR_LAST&quot;, # Your Email author_email = &quot;AUTHOR@MAIL.COM&quot;, # The URL of the GitHub Repo (optional) repo_url = NULL ) Run golem::set_golem_options() function. NOTE: This adds your information to the golem-config.yml file and sets the here package root sentinel. This is important as here manages the /root of your project. If if you change your working directory in the project, you will still be able to create modules and CSS files in their correct folders. 8.3.2 Set common files If you’d like to set your: Liscense, README, Code of Conduct, lifecycle badge, and NEWS,you can do so here. # You can set another license here usethis::use_mit_license( name = &quot;Golem User&quot; ) # Add a README, Code of Conduct, lifecycle badge and NEWS.md # file to your application usethis::use_readme_rmd( open = FALSE ) usethis::use_code_of_conduct() usethis::use_lifecycle_badge( &quot;Experimental&quot; ) usethis::use_news_md( open = FALSE ) Set up your version control account usethis::use_git() 8.3.3 Use recommended elements golem::use_recommended_tests() and golem::use_recommended_deps() sets a default testing infrastructure and adds dependencies to the application. 8.3.4 Add utility functions The next two code snippets (steps) will add various functions which can be used along the process of building your app. # These files will create R/golem_utils_ui.R # and R/golem_utils_server.R golem::use_utils_ui() golem::use_utils_server() For example, using these utilities list_to_li() is a function to turn R lists into an HTML list. Another example is with_red_star() which puts a red astrix next to a mandatory input. 8.3.5 Changing the favicon You have an option of changing icons associated with your app. By default is the golem hex. Should you provide your own favicon library, you can use this code snippet: golem::use_favicon( path = &quot;path/to/favicon&quot;) Once complete, you can move to the second step, dev/02_dev.R "],["setting-infrastructure-for-prototyping.html", "8.4 Setting infrastructure for prototyping", " 8.4 Setting infrastructure for prototyping 8.4.1 Add modules in dev/02_dev.R The golem::add_module() function creates a module in the R folder. Each module created will follow the convention mod_ and mod_*_ui and mod*server to the UI and server functions. # Creating a module skeleton golem::add_module(name = &quot;my_first_module&quot;) Here, you will paste (at the end of the file) that has to be copied and pasted inside your UI and server functions. This is the core of your application and where the development focus begins. 8.4.2 Add CSS and JS files If you have particular “look and feel” of your app in the form "],["building-an-ipsum-app.html", "Chapter 9 Building an Ipsum App ", " Chapter 9 Building an Ipsum App "],["learning-outcomes.html", "9.1 Learning Outcomes", " 9.1 Learning Outcomes Importance of Prototyping Guide the client’s focus Use different tools for prototyping different parts of an app Decouple UI, reactivity, and back-end "],["tools.html", "9.2 Tools", " 9.2 Tools {shinipsum} {fakir} usethis::use_vignette "],["prototyping-is-crucial.html", "9.3 Prototyping is crucial", " 9.3 Prototyping is crucial 9.3.1 Prototype, then polish Make things work before working on low-level optimization This makes the engineering process easier Abstraction is hard, and makes the codebase harder to work with It’s hard to identify bottlenecks up front It’s easier to spot mistakes when you have something that can run 9.3.2 The “UI first” approach helps when clarifying: what the app is supposed to do how the app is to work what each team-member is to work on use “the least possible computation” focus on appearance and interactions "],["prototyping-shiny.html", "9.4 Prototyping {shiny}", " 9.4 Prototyping {shiny} 9.4.1 Fast UI prototyping with {shinipsum} {shinipsum} generates random shiny elements example apps: https://engineering-shiny.org/shinipsum/ https://engineering-shiny.org/golemhtmltemplate/ shinipsum::random_ggplot() + labs(title = \"Random plot\") See example app in the book Also suggest {fakir} as source of example / fake datasets for use while building app "],["building-with-rmarkdown.html", "9.5 Building with RMarkdown", " 9.5 Building with RMarkdown Build the back-end without any reactive context Provides some documentation usethis::use_vignette(\"vignetteName\") 9.5.1 Define the content of the application Rendered .Rmd is shareable content Lets you focus on the core algorithm Obliges you to make back-end “application independent” (write well-documented, non-reactive functions etc) 9.5.2 Using the Rmd files as a laboratory notebook keep track of your ideas separation of work across multiple vignettes 9.5.3 Rmd, Vignettes, and documentation first Vignettes are first-class part of package infrastructure They are built during package check; so you have automated check that vignettes continue to work "],["building-the-app-with-golem.html", "Chapter 10 Building the App with {golem} ", " Chapter 10 Building the App with {golem} "],["learning-outcomes-1.html", "10.1 Learning Outcomes", " 10.1 Learning Outcomes Organise and state your dependencies Split up your code into (sub)modules Organise your functions Test everything Automate CI / CD services Golem Example "],["tools-packages-used.html", "10.2 Tools / Packages Used", " 10.2 Tools / Packages Used {attachment} golem::add_[fct|utils|module] usethis::use_[package|test|vignette|coverage|...] devtools::build_vignettes {covr}, {covrpage}, CodeCov and Coveralls CI providers: Travis, GitHub Actions, GitLab CI golem::[cat|make]_dev "],["add-dependencies.html", "10.3 Add dependencies", " 10.3 Add dependencies 10.3.1 Package dependencies Use DESCRIPTION and NAMESPACE to state / organise the package-dependencies golem::use_recommended_deps() 10.3.2 Importing packages and functions DESCRIPTION: which packages are installed when your app is installed NAMESPACE: which functions / packages are imported when app is running Specifying namespace: Manage namespace conflicts (jsonlite::flatten vs purrr::flatten) Use {roxygen2} to import specific functions or use explicit functions package::function() in R/ "],["submodules-and-utility-functions.html", "10.4 Submodules and utility functions", " 10.4 Submodules and utility functions Split your codebase into smaller pieces golem::add_fct(\"helpers\", module = NULL) adds R/fct_helpers.R Organisation: R/utils_ABC.R - small functions used throughout the app (Purpose-centered; eg, formatting) R/fct_DEF.R - larger functions that aren’t module-specific (Topic-centered; eg, db access) R/mod_XXX_[fct|utils]_YYY.R - functions relevant to a specific module golem::add_module(name = \"xxx\", fct = \"yyy\", utils = \"zzz\") "],["add-tests.html", "10.5 Add tests", " 10.5 Add tests usethis::use_test(\"topic\") tests/testthat/test-topic.R "],["documentation-and-code-coverage.html", "10.6 Documentation and code coverage", " 10.6 Documentation and code coverage 10.6.1 Vignette Long format documentation Rmd-first prototyping method Either in inst/ or vignettes/ devtools::build_vignettes() 10.6.2 Code coverage and Continuous Integration Code coverage Assess which lines in your code are covered by the tests in tests/ usethis::use_coverage() ({covr}) Test coverage may be greater, if you have puppeteer / selenium tests covr::package_coverage() Test the important stuff, and test it well Coverage metrics are easily gamed Think about: branch-coverage, not lines-covered will the tests be affected by internal restructuring would restructuring make it easier to test something that currently isn’t covered? Continuous Integration eg, for running tests every time you check in code to GitHub Providers: GitHub Actions, GitLab CI, Circle CI, Jenkins, Travis CI usethis::use_github_action prewritten actions for tests, linting, pkgdown … "],["using-golem-dev-functions.html", "10.7 Using {golem} dev functions", " 10.7 Using {golem} dev functions golem::cat_dev(\"Only prints when options(golem.app.prod = FALSE)\") golem::make_dev(some_function) "],["build-yourself-a-safety-net.html", "Chapter 11 Build Yourself a Safety Net ", " Chapter 11 Build Yourself a Safety Net "],["learning-objectives.html", "11.1 Learning Objectives", " 11.1 Learning Objectives "],["tools-and-resources.html", "11.2 Tools and Resources", " 11.2 Tools and Resources {testthat} shiny::testServer puppeteer Puppeteer Recorder {crrri} {chromote} {crrry} gremlin.js {shinyloadtest} &amp; shinycannon {shinytest} {dockerstats} {renv} Docker "],["testing-your-app.html", "11.3 Testing Your App", " 11.3 Testing Your App What to test: business logic user interface reactive connections application load 11.3.1 Testing the business logic Good practice: business logic (non-reactive) is separated from interactive logic application is inside a package Standard package development tools are available to you testthat devtools library(testthat) meaning_of_life &lt;- function() 42 describe(&quot;The meaning of life&quot;, { it(&quot;is always 42&quot;, { expect_equal(meaning_of_life(), 42) }) }) ## Test passed 🎊 11.3.2 shiny::testServer For testing reactive updates to server-side values library(shiny) # Given the following module computation_module_server &lt;- function(id, multiplier = 10) { moduleServer(id, function(input, output, session) { ns &lt;- NS(id) r &lt;- reactiveValues( value = NULL ) observeEvent(input$selector, { r$value &lt;- input$selector * multiplier }) }) } describe(&quot;&#39;value&#39;&quot;, { it(&quot;updates to &#39;multiplier&#39; * &#39;selector&#39;&quot;, { # with default multiplier testServer(computation_module_server, { session$setInputs(selector = 1) expect_equal(r$value, 10) session$setInputs(selector = 2) expect_equal(r$value, 20) }) # setting a non-default multiplier testServer(computation_module_server, args = list(multiplier = 15), { session$setInputs(selector = 3) expect_equal(r$value, 45) }) }) }) ## Test passed 🎊 11.3.3 Testing the interactive logic Several options available for testing UI and interactivity 11.3.3.1 Puppeteer Mimics a session on the app Puppeteer NodeJS module Google Chrome headless session npm install puppeteer Chrome extension Headless recorder Website Creates scripts for puppeteer and playwright This records button clicks and text input Note: you have to hit TAB after text input or it won’t be recorded [Interactive] Load Hexmake website Load Headless Recorder “Basic Usage” Click “Headless Recorder” Icon in Chrome extensions Click the BIG RED BUTTON Click “Manage Name” on hexmake page Change Name to “dupree” then hit TAB Stop the recording Copy the code to the clipboard const puppeteer = require(&#39;puppeteer&#39;); const browser = await puppeteer.launch() const page = await browser.newPage() await page.goto(&#39;https://connect.thinkr.fr/hexmake/&#39;) await page.setViewport({ width: 898, height: 926 }) await page.waitForSelector(&#39;.row &gt; .col &gt; .rounded &gt; details:nth-child(3) &gt; summary&#39;) await page.click(&#39;.row &gt; .col &gt; .rounded &gt; details:nth-child(3) &gt; summary&#39;) await page.waitForSelector(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;) await page.click(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;) await page.type(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;, &#39;dupree&#39;) await browser.close() # rerun the script node ./examples/ch11/my_puppeteer_script.js /home/russ/github/bookclub-epgs/examples/ch11/my_puppeteer_script.js:2 const browser = await puppeteer.launch() ^^^^^ SyntaxError: await is only valid in async functions and the top level bodies of modules at Object.compileFunction (node:vm:353:18) at wrapSafe (node:internal/modules/cjs/loader:1039:15) at Module._compile (node:internal/modules/cjs/loader:1073:27) at Object.Module._extensions..js (node:internal/modules/cjs/loader:1138:10) at Module.load (node:internal/modules/cjs/loader:989:32) at Function.Module._load (node:internal/modules/cjs/loader:829:14) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:76:12) This didn’t actually work. Comparing to the book example, and some other puppeteer examples, we see it should probably have looked like this: const puppeteer = require(&#39;puppeteer&#39;); (async () =&gt; { const browser = await puppeteer.launch() const page = await browser.newPage() await page.goto(&#39;https://connect.thinkr.fr/hexmake/&#39;) await page.setViewport({ width: 898, height: 926 }) await page.waitForSelector(&#39;.row &gt; .col &gt; .rounded &gt; details:nth-child(3) &gt; summary&#39;) await page.click(&#39;.row &gt; .col &gt; .rounded &gt; details:nth-child(3) &gt; summary&#39;) await page.waitForSelector(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;) await page.click(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;) await page.type(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;, &#39;dupree&#39;) await browser.close() })() node ./examples/ch11/my_fixed_puppeteer_script.js [Interactive] Try changing the script: use a non-existing selector and see the script fails use puppeteer.lauch({ headless: false }); 11.3.3.2 {crrri} and {crrry} That’s fine, but do we really want to have a node.js env in all our shiny projects? {crrri} {chromote} {crrry} - puppeteer like, tailored for {shiny} Why the strange names? they use the “Chrome remote interface” # to install {crrry} remotes::install_github(&quot;ColinFay/crrry&quot;) # Creating a new test instance test &lt;- crrry::CrrryOnPage$new( # Using the `find_chrome()` function to guess where the # Chrome bin is on our machine chrome_bin = pagedown::find_chrome(), # Launching Chrome on a random available port on our machine # Note that you will need httpuv &gt;= 1.5.2 if you want to use # this function chrome_port = httpuv::randomPort(), # Specifying the page we want to connect to url = &quot;https://connect.thinkr.fr/hexmake/&quot;, # Do everything on the terminal, with no window open headless = TRUE ) # We&#39;ll wait for the application to be ready to accept inputs test$wait_for_shiny_ready() A simple test: we input a package name then check that the updated package name matches our input name new_pkg &lt;- &quot;dupree&quot; pkg_name_selector &lt;- &quot;main_ui_1-left_ui_1-pkg_name_ui_1-package&quot; js_get_pkg &lt;- glue::glue(&quot;$(&#39;#{pkg_name_selector}&#39;).attr(&#39;value&#39;)&quot;) test$shiny_set_input(pkg_name_selector, new_pkg) test$wait_for_shiny_ready() # This (seemingly trivial) test fails: # - test$shiny_set_input doesn&#39;t change the &#39;visible&#39; input # - but, it triggers reactive changes on the server side expect_equal( test$call_js(js_get_pkg)[[&quot;result&quot;]][[&quot;value&quot;]], expected = new_pkg ) That test failed (test$set_shiny_input sets the inputs that are passed to the server). We can use javascript / jquery syntax to set the UI-attached values. new_pkg &lt;- &quot;dupree&quot; pkg_name_selector &lt;- &quot;main_ui_1-left_ui_1-pkg_name_ui_1-package&quot; js_get_pkg &lt;- glue::glue(&quot;$(&#39;#{pkg_name_selector}&#39;).attr(&#39;value&#39;)&quot;) js_set_pkg &lt;- glue::glue(&quot;$(&#39;#{pkg_name_selector}&#39;).attr(&#39;value&#39;, &#39;{new_pkg}&#39;)&quot;) test$call_js(js_set_pkg) test$wait_for_shiny_ready() expect_equal( test$call_js(js_get_pkg)[[&quot;result&quot;]][[&quot;value&quot;]], expected = new_pkg ) test$stop() Available methods: call_js() shiny_set_input() wait_for() click_on_id 11.3.3.3 gremlin 11.3.3.4 {shinytest} Similar to {puppeteer}-based tests Uses snapshots (browser images) to compare before/after source code changes [Interactive] open hexmake repo "],["further-sections.html", "11.4 Further sections", " 11.4 Further sections Did not present on: Testing the app load A reproducible environment and {renv} Docker "],["version-control.html", "Chapter 12 Version Control", " Chapter 12 Version Control Learning Objectives What version control is Why is important and how can we use it Some extra features "],["introduction-2.html", "12.1 Introduction", " 12.1 Introduction In this chapter we will focus on Git and GitHub as tools for version control, in particular while using RStudio for dealing with projects version control. "],["using-version-control-with-git.html", "12.2 Using version control with Git", " 12.2 Using version control with Git Tools: Git, GitHub or GitLab These tools let you take control of the versions of you project workflow. 12.2.1 Why version control? code disappeared need to integrating changes in my Team’s project workflow several people can synchronize and collaborate on a same project find something back from far way in time safely track changes More info on how to download and install Git and GitHub are located elsewhere: Happy Git book We assume the following: You’ve registered a free GitHub account You’ve installed/updated R and RStudio You’ve installed Git You’ve introduced yourself to Git You’ve confirmed that you can push to / pull from GitHub from the command line You will also need a test repository on GitHub 12.2.2 Git basics: add - commit - push - pull New users might be challenged for username and password. Many general Git tools require authentication. The information that is needed is your PAT. You can stored your PAT with gitcreds::gitcreds_set() command. Once this is done correctly you don’t need to do that again unless you require more strict rules on your VC tool, so that it might require you to regularly update your credentials.1 The basic commands in Git are: add: info or other addition to the project (i.e. Add a line to README and verify that Git notices the change) commit: engage the content with the repository (i.e. in RStudio click the bottom “commit” in the pane section of GitHub) The “commit” button creates a unique commit reference number: sha# And allows the user to make a comment about the commit, so to advise the others in the project or to remind the user about it. push: send the content to the server and so to the repository pull: receive the changes/updates from the repository 12.2.3 About branches The “main” branch is the one that appears at the beginning of the project, but other branches can be created. Secondary branches are work areas, usually for the other in the team to have a further layer of security of the “main” content. When you work on a shared project, your collaborators need to name a new branch to interact with the repository. This imply the creation of mirrored repositories that can be absolutely equal or slightly different, as the requested additions/modifications are accepted. 12.2.4 Issues Issues are another way to advise the main repository of some modifications that would be needed. They are used to propose changes, to track a bug or to suggest a feature, and can be done directly by the GitHub page of the repository. An issue creates a “message exchange” form of communication with the repository owner, for advising about something that can be improved. happygitwithr.com↩︎ "],["git-integration.html", "12.3 Git integration", " 12.3 Git integration 12.3.1 With RStudio In our case we are interested in how to use GitHub with RStudio, and how to set it up in a new project. There are two ways for setting up a project which is linked with a version control software support system, such as GitHub. The experience in using version controls with RStudio would be very beneficial. 12.3.2 As part of a larger world 12.3.3 About git-flow What is a git flow ? It is intended as the Git workflow, and it relates with differentiating the use of the main branch with the developer (dev) branch which is the “working in progress”. While the team merge/pull requests (MR/PR) to dev from a feature branch Branches: main dev feature branch (any given name) hot fix (to correct a critical issue in main) 7 Steps of a software engineer daily work flow: Identify an issue to work on Fork dev into issue-XXX Develop a feature inside the branch. Regularly run git stash, git rebase dev, and git stash apply to include the latest changes from dev to stay synchronized with dev. Make a pull request to dev so that the feature is included. Once the PR is accepted by the project manager, notify the rest of the team that there have been changes to dev, so they can rebase it to the branch they are working on. Start working on a new feature. "],["automated-testing.html", "12.4 Automated testing", " 12.4 Automated testing The book mention some “health check” repository software integration: Travis CI Note that Travis CI can run tests on GNU/Linux or MacOS operating systems Appveyor It supports Windows, as well GitHub actions It is the most common used With Travis usethis::use_travis() the events described in the travis configuration file (.travis.yml) are executed (with a binary outcome: 0/1) before merging any pull request, the project manager has access to a series of tests that are automatically launched. While with GitHub Action the command are the following, the first three perform a standard R CMD check, while use_github_action_pr_commands() sets checks to be performed when a pull request is made to the repository usethis::use_github_action_check_release() use_github_action_check_standard() use_github_action_check_full() use_github_action_pr_commands() One more feature is: GitLab CI service is a Docker-based container "],["conclusions.html", "12.5 Conclusions", " 12.5 Conclusions Version control tools are useful to secure you work against some annoying inconveniences. Also automated procedures would help maintain resilient applications. 12.5.1 Resources Happy Git Git Cheat Sheet A git flow Understanding a git flow GitSvnComparison Git Pro Book Git Branching Basic Branching and Merging GitHub Actions for the R language R CMD check hub.docker "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
