[["index.html", "Engineering Production-Grade Shiny Apps Book Club Welcome", " Engineering Production-Grade Shiny Apps Book Club The R4DS Online Learning Community 2021-11-10 Welcome This is a companion for the book Engineering Production-Grade Shiny Apps by Colin Fay, Sébastien Rochette, Vincent Guyader, and Cervan Girard. This companion is available at r4ds.io/epgs. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book. This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["about-successful-shiny-apps.html", "Chapter 1 About Successful {shiny} Apps", " Chapter 1 About Successful {shiny} Apps Learning objectives: Intro to shiny Consider application complexity from different viewpoints "],["introduction.html", "1.1 Introduction", " 1.1 Introduction 1.1.1 Motivation for the book (&amp; the bookclub) 1.1.2 Audience for the book (experienced) shiny devs managers 1.1.3 What is “Production”? Used Relied upon Real life impact "],["intro-to-shiny.html", "1.2 Intro to {shiny}", " 1.2 Intro to {shiny} Building apps in R .. without necessarily needing HTML, CSS, JS training Need {shiny} apps always be a proof-of-concept? "],["what-is-a-complex-shiny-application.html", "1.3 What is a complex {shiny} application?", " 1.3 What is a complex {shiny} application? Complexity: [a complex system] defies any single person&#39;s ability to see [and understand] the system as a whole Consequences: Bug chasing Steep learning curve "],["types-of-complexity.html", "1.4 Types of complexity", " 1.4 Types of complexity Developer complexity Implementation Development Deployment Customer / User complexity Interface "],["code-complexity.html", "1.5 Code complexity", " 1.5 Code complexity Lines of code Number of files Cyclomatic complexity Other sources: Inconsistency Indentation Untested code Dependency-bloat Maintenance and Use Merge-conflicts per week … "],["app-complexity.html", "1.6 App complexity?", " 1.6 App complexity? External dependencies: databases, APIs etc Number of contributors "],["what-is-a-successful-shiny-app.html", "1.7 What is a successful {shiny} app?", " 1.7 What is a successful {shiny} app? Existence Accuracy Usability Immortality "],["meeting-videos.html", "1.8 Meeting Videos", " 1.8 Meeting Videos 1.8.1 Cohort 1 Meeting chat log 00:10:22 Ryan Metcalf: https://unleash-shiny.rinterface.com/index.html "],["planning-ahead.html", "Chapter 2 Planning Ahead ", " Chapter 2 Planning Ahead "],["prepare-for-success.html", "2.1 Prepare for Success", " 2.1 Prepare for Success Learning Objectives: Learn the KISS method Establish good version control and CI / Test Comprehend development team hierarchy French proverb: Rome ne fut pas faite toute en un jour. English Translation: Rome was not made all in one day. The chapter is preparing for a project Projects that aren’t planned well encure additional cost to unwrangle bad code Setting Version Control Organizing a hierarchy of personnel The sooner you start with a robust framework the better, and the longer you wait the harder it gets to convert your application to a production-ready one. "],["develop-with-the-kiss-principle.html", "2.2 Develop with the KISS principle", " 2.2 Develop with the KISS principle Definition: Keep It Simple Stupid Kelly Johnson of Lockheed Skunkworks Develop with a common set of tools Tidyverse Dplyr ggplot2 etc… Expand on this topic for military style of lowest common denominator. Simple is success. Various levels of workforce aptitude lead towards varying degrees of success If your team chooses to use abstract packages or web applications, ensure there is a good reason. The more complex you build your orchestration, the harder it will be to find talent to maintain the service. Example: Microsoft or Oracle "],["working-as-a-team-tools-and-structure.html", "2.3 Working as a team: Tools and structure", " 2.3 Working as a team: Tools and structure The choice of tools and how the team is structured is crucial for a successful application. Not entirely like KISS, but close too it. GitHub versus GitLab. Barebones hardware or Containerization. 2.3.1 From the tools point of view Version control and test all things Use Constant Innovation (CI) principles to test all code before committing Breaking things is a natural process of software engineering, notably when working on a piece of code during a long period Be informed that the codebase is broken Be able to identify changes between versions, and potentially, get back in time to a previous codebase Github/GitLab diff-docs. Example: Branch -&gt; Change -&gt; Test -&gt; Commit -&gt; Pull Request -&gt; Merge Small is beautiful Smaller more managable pieces make it easier to develop Teams may even work in parallel (with caution) A large codebase implies that the safe way to work is to split the app into pieces Extract your core “non-reactive” functions, which we will also call the “business logic”, and include them in external files Non-vital linkages (data ingestion pipelines) Page Layout and theming (CSS or branding characteristics) Allows for expansion but won’t break the core 2.3.2 From the team point of view Select a Manager, maybe a stakeholder or project manager. Someone who may or may not work on the codebase but is aware and knowledgeable Select one or more core developers skilled but specific in their field of study Follow git workflow with issue tracking and managing pull requests ## Reference Lemaire, Maude. 2020. Refactoring at Scale. Henry Holt. NOTE: Payed Service "],["structuring-your-project.html", "Chapter 3 Structuring Your Project", " Chapter 3 Structuring Your Project Learning Objectives Learn the golem file structure for building shiny apps Manage Dependencies and Namespace files Apply proper documentation principles for app maintenance, use, and future development Comprehend the future use of golem "],["shiny-app-as-a-package.html", "3.1 {shiny} app as a package", " 3.1 {shiny} app as a package golem is an opinionated framework for building production-ready {shiny} applications learn the basic now…the rest of the book relies on it 3.1.1 What is in a production-grade {shiny} app? Use one single file, or split into two?….that is the question! We will discover, this is an arbitrary question when managing large production level shiny apps Modulizing code will be your success factor It has metadata This could include: naming convention, version numbering, what the app does, who to contact when it breaks….and it WILL break It handles dependencies You need to handle them, and handle them correctly if you want to ensure a smooth deployment to production DESCRIPTION: contains the packages your application depends on NAMESPACE: contains the functions/packages you need to import It’s split into functions When apps get big…spread the wealth to smaller manageable files The smaller files go into the R/ directory It has documentation Document, Document, Document!!! README can be simple like a markdown file Vignettes are a bit more complex, possibly with examples Function documentation could include inline notes You may even create a {pkgdown} webpage for IT and other developers It’s tested Nothing should go to production without being tested. Nothing. examples could include {testhat} There is a native way to build and deploy it Finally, create a tar.gz file to make it easy for distribution 3.1.2 Resources R packages Building a Package that Lasts Writing R Extensions R Package Primer - a Minimal Tutorial "],["using-shiny-modules.html", "3.2 Using {shiny} modules", " 3.2 Using {shiny} modules Modulizing code will be your success factor 3.2.1 Why {shiny} modules? The one million “Validate” buttons problem Creating small namespaces where you can safely define ids without conflicting with other ids in the app When you single app gets bigger….UI and Server exchange may be hundreds or thousands of lines apart. That is a lot of scrolling! Working with a bite-sized codebase if you copy and paste something more than twice, you should make a function {shiny} modules aim at three things: simplify “id” namespacing split the codebase into a series of functions allow UI/Server parts of your app to be reused Most of the time, modules are used to do the two first. In our case, we could say that 90% of the modules we write are never reused, they are here to allow us to split the codebase into smaller, more manageable pieces. 3.2.2 When to use {shiny} modules Start right from the beginning Yes, this takes a bit more time, but you will be saving yourselve volumes in the future (Your future self will love you!) 3.2.3 A practical walkthrough (Big code base example. Talk through the best way to compare) 1. Your first {shiny} module 2. Passing arguments to your modules - UseLink 3.2.4 Communication between modules Three primary ways to share data amongst modules: - Returning a reactive function - The “stratégie du petit r” (to be pronounced with a French accent of course) - The “stratégie du grand R6” Returning values from the module using reactive calls is costly on the server The “stratégie du petit r” creates a sudo database shared amongst modules. More efficent, but not eloquent The “stratégie du grand R6” {R6} package. The best of both worlds may be foreign to some Other approaches: About {tidymodules} "],["structuring-your-app.html", "3.3 Structuring your app", " 3.3 Structuring your app A shiny app has two main components: - Application logic is what makes your {shiny} app interactive - Business logic includes the components with the core algorithms and functions that make your application specific to your area of work 3.3.1 Small is beautiful (bis repetita) Long scripts are almost always synonymous with complexity when it comes to building software 3.3.2 Conventions matter app_*.R (typically app_ui.R and app_server.R) contain the top-level functions defining your user interface and your server function. fct_* files contain the business logic, which are potentially large functions. They are the backbone of the application and may not be specific to a given module. They can be added using {golem} with the add_fct(“name”) function. mod_* files contain a unique module. Many {shiny} apps contain a series of tabs, or at least a tab-like pattern, so we suggest that you number them according to their step in the application. Tabs are almost always named in the user interface, so that you can use this tab name as the file name. For example, if you build a dashboard where the first tab is called “Import”, you should name your file mod_01_import.R. You can create this file with a module skeleton using golem::add_module(“01_import”). utils_* are files that contain utilities, which are small helper functions. For example, you might want to have a not_na, which is not_na &lt;- Negate(is.na), a not_null, or small tools that you will be using application-wide. Note that you can also create utils for a specific module. *_ui_*, for example utils_ui.R, relates to the user interface. *_server_* are files that contain anything related to the application’s back-end. For example, fct_connection_server.R will contain functions that are related to the connection to a database, and are specifically used from the server side. "],["user-experience---ux.html", "Chapter 4 User experience - UX", " Chapter 4 User experience - UX Learning objectives: the key factors for a successful app understanding of your audience behavior "],["introduction-1.html", "4.1 Introduction", " 4.1 Introduction This chapter focuses on the key factors for making a Shiny app successful. Figure 4.1: Shiny success The back-yard vs the front-end The first take away of this chapter is that thinking about the “behind the scene” of your building app can be challenging for a successful front-end. "],["simplicity-is-gold.html", "4.2 Simplicity is gold", " 4.2 Simplicity is gold Establish some rules about your app to be: simple the app must be fast usable straightforward easy to approach and use Based on the identification of the destination of the app: for professional use for fun The quicker you understand the interface, the better the user experience (in business) Don’t fight against the app but enjoy it (for fun) Figure 4.2: Yes and No of your app Yes: “self-explanatory” but with detailed explanations an efficient tool No: fight with interface read complex material lose time understanding how to use it Two more important rules: “don’t make me think” “rule of least surprise”: “Principle of Least Astonishment” 4.2.1 How we read the web: Scanning content The second part of this chapter focuses on what your audience is actually seeing about the app. The user of your app doesn’t read everything, but will be searching for “How to”? Figure 4.3: “How to”? The user might act unexpectedly on you app adopt “defensive programming” mindset is a workaround the unexpected: inherent logic in the application: each sub-menu is designed to handle one specific part of your app rational choice: rationality plays a good game but it is less than expected when up to a new app “irrational” choices: examine the back-end for unexpected behaviors \"organisms adapt well enough to ‘satisfice’; they do not, in general, optimize.“ by Herbert A. Simon To be failing gracefully and informatively can sometimes happen, but do not forget to put an informative bug message to avoid a grayish version of the application. Under some conditions you might not have the complete manner of all that is linked with your app (such as widgets in {DT} package) Good practices: add a bug message wrap all server calls (in case of crash reduce the amount of data loss) use a notification function with {shinyalert} and/or {attempt} packages As an example, if we want our app to be connected to a database, we use connect_db() connection in the server(). If the connection fails, we notify the user: conn &lt;- attempt::attempt({ connect_db() }) if (attempt::is_try_error(conn)){ # Notify the user send_notification(&quot;Could not connect&quot;) } else { # Continue computing if the connection was successful continue_computing() } 4.2.2 Building a self-evident app (or at least self-explanatory) self-evident: no demo required self-explanatory: no explanation required A. About the “Rule of Least Surprise” and the “Principle of Least Astonishment” various text customization lead to conventional thinking B. Thinking about progression design a clear pattern of moving forward hide elements at step n+1 until all the requirements are fulfilled at step n. ensure some kind of linear logic through increasing readability compare {tidytuesday201942} to {hexmake} C. Inputs and errors Your user is BUSY BUSY BEE …. In the UI: useShinyFeedback() In the server(): showFeedbackWarning() hideFeedback() ( the notifyjsexample repository link doesn’t work ) "],["the-danger-of-feature-creep.html", "4.3 The danger of feature-creep", " 4.3 The danger of feature-creep Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do. The Art of UNIX Programming (Raymond 2003) 4.3.1 What is feature-creep? The process of adding features to the app that complicate the usage and the maintenance of the product, such as: easier navigation more information more visualizations modifiable elements … What’s behind feature-creep? adding more and more things most often leads to: a slower app worse user experience steeper learning curve 4.3.2 Too much reactivity Prevent the implementation of “full reactivity” This is a very important part of how to make an app working smoothly, releasing the best experience to users. The book reminds that: people make mistakes while using the app be sure your app doesn’t update all the times at any given imputs If the application reacts to all of the moves, the experience using the app can be bad, imagine that all the elements on the app update at any user input The best solution is to add one reactive button to give the user the opportunity to update results once all the changes have been made. 4.3.3 Too much interactivity A. Speed: use the features that assure fast visualizations at a given input B. Visual noise: reduce the numbers of extra features "],["web-accessibility.html", "4.4 Web accessibility", " 4.4 Web accessibility 4.4.1 About accessibility Audience: large audience Figure 4.4: Accessibility in Context 4.4.2 Making your app accessible A. Hierarchy: respect the order of importance B. HTML element: Semantic tags, and tag metadata: without “meanings”: &lt;div&gt; or &lt;span&gt; have a specific “meanings”: meaningful (Semantic tags) &lt;title&gt; or &lt;article&gt; &lt;address&gt;, &lt;video&gt;, or &lt;label&gt; metadata alt we can use the tagAppendAttributes() ui &lt;- function(){ tagList( plotOutput(&quot;plot&quot;) %&gt;% # Adding the `alt` attribute to our plot tagAppendAttributes(alt = &quot;Plot of iris&quot;) ) } It will be crucial to screen-to-speech technology: the software will read the &lt;title&gt; tag, jump to the &lt;nav&gt;, or straight to the ` on the page. C. Navigation: make everything doable with a keyboard textInput() with a validation button and {nter} package # Adapted from https://github.com/JohnCoene/nter library(nter) library(shiny) ui &lt;- fluidPage( # Setting a text input and a button textInput(&quot;text&quot;, &quot;&quot;), # This button will be clicked when &#39;Enter&#39; is pressed in # the textInput text actionButton(&quot;send&quot;, &quot;Do not click hit enter&quot;), verbatimTextOutput(&quot;typed&quot;), # define the rule nter(&quot;send&quot;, &quot;text&quot;) ) server &lt;- function(input, output) { r &lt;- reactiveValues() # Define the behavior on click observeEvent( input$send , { r$printed &lt;- input$text }) # Render the text output$typed &lt;- renderPrint({ r$printed }) } shinyApp(ui, server) D. Color choices: recommended to use provided color composition such as viridis or other specific combinations. Here as an example is the build of a function, but other packages can be used such as {dichromat} packages which simulates color blindness. with_palette &lt;- function(palette) { x &lt;- y &lt;- seq(-8 * pi, 8 * pi, len = 40) r &lt;- sqrt(outer(x^2, y^2, &quot;+&quot;)) z &lt;- cos(r^2) * exp(-r / (2 * pi)) filled.contour( z, axes = FALSE, color.palette = palette, asp = 1 ) } with_palette(matlab::jet.colors) 4.4.3 Evaluating your app accessibility and further reading How to evaluate accessibility? A. Emulate vision deficiency using Google Chrome B. External tools "],["references.html", "4.5 References", " 4.5 References shinyalert Hexmake app Accessibility Freecodecamp - tutorial nter package Color blindness "],["developer-patience---dont-rush-into-coding.html", "Chapter 5 Developer patience - Don’t rush into coding", " Chapter 5 Developer patience - Don’t rush into coding Learning objectives: thinking about the Big Picture building Personas the IT side of your application "],["designing-before-coding.html", "5.1 Designing before coding", " 5.1 Designing before coding Figure 5.1: Designing before coding: credits 5.1.1 The urge to code technical implementation: search for an existent soultion packages pieces of code … Figure 5.2: The Big Picture credits Thinking about the Big Picture helps in designing your app: what are the inputs what are the outputs what packages/services can you use inside your application how will it fit in the rest of the project … 5.1.2 Knowing where to search R and {shiny} resources Web resources 5.1.3 About concept map take a piece of paper and draw all the concepts, and all the relationships that link these concepts together. Figure 5.3: The Concept Map credits Figure 5.4: The HexmakeMap credits Can we point to any concept and confirm it’s there? Can we look at every relationship and see they all work as expected? "],["ask-questions.html", "5.2 Ask questions", " 5.2 Ask questions Figure 5.5: Ask questions credits 5.2.1 About the end users Who are the end users of your app? Are they tech-literate? In which context will they be using your app? On what machines (computer, tablet, smartphone, or any other device)? Are there any restrictions when it comes to the browser they are using? (For example, are they still using an old version of Internet Explorer?) Will they be using the app in their office, on their phone while driving a tractor, in a plant, or while wearing a lab coat? Some more: Do the users really need that much interactive plots? Do they actually need that much granularity in the information? Will they really see a datatable of 15k lines? Do they really care about being able to zoom in the dygraph so that they can see the point at a minute scale? To what extent does the app have to be fast? 5.2.2 Building personas Helps you focusing on the end user and the “typical” behavior and traits for a group of users. Figure 5.6: Get a feeling of its personality credits Will they use it? Will they understand it? Do we need to add extra information? Will they find this useful? 5.2.3 Pre-existing code-base “brownfield projects”: existing code-base “greenfield projects”: start from scratch 5.2.4 Deployment deploying with Docker: a container on your machine IT side of your application Here is a nice story: Once deployed, the app stopped working, and the team lost a couple of days of exchanges with the client, trying to debug the API calls, until we realized that the issue was not with the app, but with the production server itself: and nobody in the team, not the developers or the client, thought about asking about internet access for the server. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
