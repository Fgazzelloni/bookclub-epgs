[["index.html", "Engineering Production-Grade Shiny Apps Book Club Welcome", " Engineering Production-Grade Shiny Apps Book Club The R4DS Online Learning Community 2021-09-29 Welcome This is a companion for the book Engineering Production-Grade Shiny Apps by Colin Fay, Sébastien Rochette, Vincent Guyader, and Cervan Girard. This companion is available at r4ds.io/epgs. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book. This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["about-successful-shiny-apps.html", "Chapter 1 About Successful {shiny} Apps", " Chapter 1 About Successful {shiny} Apps Learning objectives: Intro to shiny Consider application complexity from different viewpoints "],["introduction.html", "1.1 Introduction", " 1.1 Introduction 1.1.1 Motivation for the book (&amp; the bookclub) 1.1.2 Audience for the book (experienced) shiny devs managers 1.1.3 What is “Production”? Used Relied upon Real life impact "],["intro-to-shiny.html", "1.2 Intro to {shiny}", " 1.2 Intro to {shiny} Building apps in R .. without necessarily needing HTML, CSS, JS training Need {shiny} apps always be a proof-of-concept? "],["what-is-a-complex-shiny-application.html", "1.3 What is a complex {shiny} application?", " 1.3 What is a complex {shiny} application? Complexity: [a complex system] defies any single person&#39;s ability to see [and understand] the system as a whole Consequences: Bug chasing Steep learning curve "],["types-of-complexity.html", "1.4 Types of complexity", " 1.4 Types of complexity Developer complexity Implementation Development Deployment Customer / User complexity Interface "],["code-complexity.html", "1.5 Code complexity", " 1.5 Code complexity Lines of code Number of files Cyclomatic complexity Other sources: Inconsistency Indentation Untested code Dependency-bloat Maintenance and Use Merge-conflicts per week … "],["app-complexity.html", "1.6 App complexity?", " 1.6 App complexity? External dependencies: databases, APIs etc Number of contributors "],["what-is-a-successful-shiny-app.html", "1.7 What is a successful {shiny} app?", " 1.7 What is a successful {shiny} app? Existence Accuracy Usability Immortality "],["meeting-videos.html", "1.8 Meeting Videos", " 1.8 Meeting Videos 1.8.1 Cohort 1 Meeting chat log 00:10:22 Ryan Metcalf: https://unleash-shiny.rinterface.com/index.html "],["planning-ahead.html", "Chapter 2 Planning Ahead ", " Chapter 2 Planning Ahead "],["prepare-for-success.html", "2.1 Prepare for Success", " 2.1 Prepare for Success Learning Objectives: Learn the KISS method Establish good version control and CI / Test Comprehend development team hierarchy French proverb: Rome ne fut pas faite toute en un jour. English Translation: Rome was not made all in one day. The chapter is preparing for a project Projects that aren’t planned well encure additional cost to unwrangle bad code Setting Version Control Organizing a hierarchy of personnel The sooner you start with a robust framework the better, and the longer you wait the harder it gets to convert your application to a production-ready one. "],["develop-with-the-kiss-principle.html", "2.2 Develop with the KISS principle", " 2.2 Develop with the KISS principle Definition: Keep It Simple Stupid Kelly Johnson of Lockheed Skunkworks Develop with a common set of tools Tidyverse Dplyr ggplot2 etc… Expand on this topic for military style of lowest common denominator. Simple is success. Various levels of workforce aptitude lead towards varying degrees of success If your team chooses to use abstract packages or web applications, ensure there is a good reason. The more complex you build your orchestration, the harder it will be to find talent to maintain the service. Example: Microsoft or Oracle "],["working-as-a-team-tools-and-structure.html", "2.3 Working as a team: Tools and structure", " 2.3 Working as a team: Tools and structure The choice of tools and how the team is structured is crucial for a successful application. Not entirely like KISS, but close too it. GitHub versus GitLab. Barebones hardware or Containerization. 2.3.1 From the tools point of view Version control and test all things Use Constant Innovation (CI) principles to test all code before committing Breaking things is a natural process of software engineering, notably when working on a piece of code during a long period Be informed that the codebase is broken Be able to identify changes between versions, and potentially, get back in time to a previous codebase Github/GitLab diff-docs. Example: Branch -&gt; Change -&gt; Test -&gt; Commit -&gt; Pull Request -&gt; Merge Small is beautiful Smaller more managable pieces make it easier to develop Teams may even work in parallel (with caution) A large codebase implies that the safe way to work is to split the app into pieces Extract your core “non-reactive” functions, which we will also call the “business logic”, and include them in external files Non-vital linkages (data ingestion pipelines) Page Layout and theming (CSS or branding characteristics) Allows for expansion but won’t break the core 2.3.2 From the team point of view Select a Manager, maybe a stakeholder or project manager. Someone who may or may not work on the codebase but is aware and knowledgeable Select one or more core developers skilled but specific in their field of study Follow git workflow with issue tracking and managing pull requests ## Reference Lemaire, Maude. 2020. Refactoring at Scale. Henry Holt. NOTE: Payed Service "],["structuring-your-project.html", "Chapter 3 Structuring Your Project", " Chapter 3 Structuring Your Project Learning Objectives Learn the golem file structure for building shiny apps Manage Dependencies and Namespace files Apply proper documentation principles for app maintenance, use, and future development Comprehend the future use of golem "],["shiny-app-as-a-package.html", "3.1 {shiny} app as a package", " 3.1 {shiny} app as a package golem is an opinionated framework for building production-ready {shiny} applications learn the basic now…the rest of the book relies on it 3.1.1 What is in a production-grade {shiny} app? Use one single file, or split into two?….that is the question! We will discover, this is an arbitrary question when managing large production level shiny apps Modulizing code will be your success factor It has metadata This could include: naming convention, version numbering, what the app does, who to contact when it breaks….and it WILL break It handles dependencies You need to handle them, and handle them correctly if you want to ensure a smooth deployment to production DESCRIPTION: contains the packages your application depends on NAMESPACE: contains the functions/packages you need to import It’s split into functions When apps get big…spread the wealth to smaller manageable files The smaller files go into the R/ directory It has documentation Document, Document, Document!!! README can be simple like a markdown file Vignettes are a bit more complex, possibly with examples Function documentation could include inline notes You may even create a {pkgdown} webpage for IT and other developers It’s tested Nothing should go to production without being tested. Nothing. examples could include {testhat} There is a native way to build and deploy it Finally, create a tar.gz file to make it easy for distribution 3.1.2 Resources R packages Building a Package that Lasts Writing R Extensions R Package Primer - a Minimal Tutorial "],["using-shiny-modules.html", "3.2 Using {shiny} modules", " 3.2 Using {shiny} modules Modulizing code will be your success factor 3.2.1 Why {shiny} modules? The one million “Validate” buttons problem Creating small namespaces where you can safely define ids without conflicting with other ids in the app When you single app gets bigger….UI and Server exchange may be hundreds or thousands of lines apart. That is a lot of scrolling! Working with a bite-sized codebase if you copy and paste something more than twice, you should make a function {shiny} modules aim at three things: simplify “id” namespacing split the codebase into a series of functions allow UI/Server parts of your app to be reused Most of the time, modules are used to do the two first. In our case, we could say that 90% of the modules we write are never reused, they are here to allow us to split the codebase into smaller, more manageable pieces. 3.2.2 When to use {shiny} modules Start right from the beginning Yes, this takes a bit more time, but you will be saving yourselve volumes in the future (Your future self will love you!) 3.2.3 A practical walkthrough (Big code base example. Talk through the best way to compare) 1. Your first {shiny} module 2. Passing arguments to your modules - UseLink 3.2.4 Communication between modules Three primary ways to share data amongst modules: - Returning a reactive function - The “stratégie du petit r” (to be pronounced with a French accent of course) - The “stratégie du grand R6” Returning values from the module using reactive calls is costly on the server The “stratégie du petit r” creates a sudo database shared amongst modules. More efficent, but not eloquent The “stratégie du grand R6” {R6} package. The best of both worlds may be foreign to some Other approaches: About {tidymodules} "],["structuring-your-app.html", "3.3 Structuring your app", " 3.3 Structuring your app A shiny app has two main components: - Application logic is what makes your {shiny} app interactive - Business logic includes the components with the core algorithms and functions that make your application specific to your area of work 3.3.1 Small is beautiful (bis repetita) Long scripts are almost always synonymous with complexity when it comes to building software 3.3.2 Conventions matter app_*.R (typically app_ui.R and app_server.R) contain the top-level functions defining your user interface and your server function. fct_* files contain the business logic, which are potentially large functions. They are the backbone of the application and may not be specific to a given module. They can be added using {golem} with the add_fct(“name”) function. mod_* files contain a unique module. Many {shiny} apps contain a series of tabs, or at least a tab-like pattern, so we suggest that you number them according to their step in the application. Tabs are almost always named in the user interface, so that you can use this tab name as the file name. For example, if you build a dashboard where the first tab is called “Import”, you should name your file mod_01_import.R. You can create this file with a module skeleton using golem::add_module(“01_import”). utils_* are files that contain utilities, which are small helper functions. For example, you might want to have a not_na, which is not_na &lt;- Negate(is.na), a not_null, or small tools that you will be using application-wide. Note that you can also create utils for a specific module. *_ui_*, for example utils_ui.R, relates to the user interface. *_server_* are files that contain anything related to the application’s back-end. For example, fct_connection_server.R will contain functions that are related to the connection to a database, and are specifically used from the server side. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
